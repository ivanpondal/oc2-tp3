\subsection{Pasaje a modo protegido y segmentación}
En esta sección explicaremos como realizamos la creación de la \textit{Global Descriptor Table} (GDT) y como, una vez hecho esto, pasamos a modo protegido.

\subsubsection{Inicialización de la GDT}
Del código que viene dado se deben agregar en principio cinco segmentos (Para la parte de tareas tuvimos que agregar algunos mas los cuales serán explicados en su correspondiente sección), estos estan conformados por dos de datos, dos de código y uno de la pantalla de video, con niveles de privilegio de 0 o 3.

Para esto seteamos cada segmento, a partir del indice 8 de la gdt por restricciones del trabajo práctico. Las posiciones anteriores a la 8 quedan en 0. Los cuatro primeros segmentos direccionan los primeros 500 MB de memoria, desde la posición 0 hasta el megabyte número 500, en ese espacio entran 128.000 (0x1F400) bloques de 4 KB por lo tanto el limite sera 0x1F3FF ya que contamos desde el 0, los de codigo son del tipo 10 (0x0A) y los de datos del tipo (0x01), el limite es (0xF3FF) y el nivel de privilegio 0 o 3 segun corresponda. La granularidad esta activada (0x01). Los bits P, L, D/B y AVL se ponen en 1, 0, 1 y 0 respectivamente para todas las entradas.

\subsubsection{Pasaje a modo protegido}

Antes de pasar a modo protegido el sistema operativo necesita saber donde esta la gdt y cual es su tamaño para esto cargamos a traves de lgdt el registro gdtr el cual tiene esta información. También habilitamos A20 para permitir el acceso a direcciones superiores a $2^{20}$ bits.

Luego realizamos un salto con la instruccion \textit{jmp 0x40:modoprotegido} para poner a cs en el valor correcto, el 0x40 es para posicionarnos en el segmento de codigo de nivel 0 (indice 8 en la gdt). Una vez hecho esto estamos listos para pasar a modo protegido poniendo el bit PE de cr0 en 1. 

Luego debemos establecer los selectores de segmentos de datos de nivel 0 y la base de la pila la cual se requirió que estuviera en la posición 0x27000

\begin{lstlisting}
	mov ax, 0x50	
	mov ds, ax
	mov es, ax
	mov gs, ax
	mov fs, ax
	mov ss, ax
	mov ebp, 0x27000
	mov esp, ebp
\end{lstlisting}

Hay un segmento mas que seteamos con el único objetivo de verificar el buen funcionamiento de la segmentación, este es \textit{GDT\_ID12\_SCREEN\_DESC}, en la funcion \textit{pintar\_esquina\_superior\_izquierda} definida en \textit{kernelasm} se puede ver como accedemos al segmento y luego reescribimos los dos primeros pixels de la pantalla

\begin{lstlisting}
	pintar_esquina_superior_izquierda:
	mov ax, 0x60	; Offset de SCREEN
	mov ds, ax
	mov byte [0x0], 'X'
	mov byte [0x1], 0x4
	mov ax, 0x50	; Offset de KERNEL_DATA
	mov ds, ax
	ret	
\end{lstlisting}

\subsection{Interrupciones básicas}
En esta sección explicaremos como realizamos la creación de la \textit{Interrupt Descriptors Table} (IDT) y su posterior carga en el \textit{kernel}.

\subsubsection{Inicialización de la IDT}
La IDT es un arreglo de tamaño 255 de \texttt{idt\_entry}, la cual posee los campos a setear de una \textit{interrupt gate}. Como en este apartado solo nos interesa asociar las excepciones internas del procesador, únicamente generamos las primeras 20 entradas de la tabla, siguiendo la tabla 6-1 del tercer volumen del manual de Intel \footnote{Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3: System programming guide, Chapter 6}. Para inicializarla, utilizamos la función \texttt{idt\_inicializar} definida en \texttt{idt.c}, y cuya implementación se basa en llamar 20 veces al macro \texttt{IDT\_ENTRY}, definido en el mismo archivo, con los respectivos números de la excepción y el privilegio del descriptor (que en este caso querremos que sea siempre 0, pues es el \textit{kernel} quien manejará estas excepciones).

La principal tarea de esta sección es, entonces, configurar correctamente la macro \texttt{IDT\_ENTRY}. También tendremos definidas 20 rutinas de atención para cada excepción, aunque de momento lo único que harán es mover el número de la excepción a \texttt{eax} y detener la ejecución del sistema. En el futuro, la rutina se encargará de desalojar la tarea que produjo la excepción y continuar con la ejecución.
En la figura (\ref{fig:interrupt-gate}) mostramos como seteamos la entrada de la IDT correspondiente a la excepción $n$ del procesador.
\vspace{1em}

\begin{figure}[H]
\begin{center}
\begin{bytefield}[endianness=big,bitwidth=0.03125\linewidth]{32}
	\bitheader{0,4,5,7,8,12,13,14,15,16,31}\\
	\bitbox{16}{\texttt{\&\_isr}\emph{n}[31:16]} & \bitbox{1}{1} & \bitbox{2}{00} & \bitbox{1}{0} & \bitbox{1}{1} & \bitbox{3}{110} & \bitbox{3}{000} & \bitbox{5}{00000} \\
  	\bitbox{16}{Offset (parte alta)} & \bitbox{1}{P} & \bitbox{2}{DPL} & \bitbox{1}{M} & \bitbox{1}{D} & \bitbox{3}{\footnotesize Interrupt gate} & \bitbox{3}{M} & \bitbox{5}{Reserved} \\
\end{bytefield}

\begin{bytefield}[endianness=big,bitwidth=0.03125\linewidth]{32}
	\bitheader{0,16,31}\\
	\bitbox{16}{0x40} & \bitbox{16}{\texttt{\&\_isr}\emph{n}[15:0]}\\
  	\bitbox{16}{Segment Selector} & \bitbox{16}{Offset (parte baja)}\\
\end{bytefield}
\end{center}
\caption{Interrupt gate correspondiente a la excepción $n$ del procesador. \texttt{\_isr}$n$ es la rutina de atención de la interrupción $n$, mientras que \&\texttt{\_isr}$n$ es la dirección donde se encuentra alojada la misma; el bit D en 1 indica que el gate es de 32bits. La M implica que el manual pide que esos bits estén seteados de esa forma.}  
\label{fig:interrupt-gate}
\end{figure}

Es importante destacar que el selector de segmento 0x40 corresponde a un segmento de código, pues recordemos que lo que esperamos encontrar en la dirección 0x40:\texttt{\&\_isr}\emph{n} es el código de un \textit{handler} de interrupción.
Además, el segmento requiere privilegio de \textit{kernel}, lo cual es razonable pues esperamos que sea este quien resuelva las excepciones. 

\subsubsection{Carga de la IDT}
Para cargar el descriptor de la IDT (compuesto por su posición base y su tamaño) al IDTR usamos la operación \texttt{lidt} de la siguiente forma desde \texttt{kernel.asm}
\begin{lstlisting}
	lidt [IDT_DESC]
\end{lstlisting}

\subsection{Paginación básica}

Aquí contaremos los pasos necesarios para poder activar la paginación y que esta
esté configurada para realizar \textit{identity mapping}. Este término se
utiliza para describir un direccionamiento de memoria donde la dirección virtual
coincide uno a uno con la física.

Las páginas que definimos nos mapean las direcciones
\texttt{0x00000000} a \texttt{0x003FFFFF}, el directorio de páginas se encuentra
en la dirección \texttt{0x27000} y la tabla de páginas en \texttt{0x28000}.

\subsubsection{Rutinas de mapeado y desmapeado}

Escribimos dos rutinas para realizar la tarea, la de mapeado que nos permite
asociar una dirección virtual con una física, y la de desmapeado que dada una
dirección virtual la desasocia de memoria.

\subsubsection*{Mapeado}

La función \texttt{mmu\_mapear\_pagina} toma como parámetros la dirección \texttt{virtual}, el contenido del
registro \texttt{cr3}, la dirección \texttt{física} y por último los atributos
\texttt{attrs}.

\begin{enumerate}
	\item Extraemos la dirección del directorio de tablas de \texttt{cr3}.
	\begin{lstlisting}
	base_directorio_tablas = 0xFFFFF000 AND cr3
	\end{lstlisting}

	\item Calculamos el offset dentro del directorio de tablas en base a
	\texttt{virtual}.
	\begin{lstlisting}
	offset_directorio_tablas = ((0xFFC00000 AND virtual) >> 22) << 2
	\end{lstlisting}

	\item Obtenemos el Page Directory Entry correspondiente.
	\begin{lstlisting}
	pde = *(base_directorio_tablas + offset_directorio_tablas)
	\end{lstlisting}

	\item Extraemos la dirección del directorio de páginas de \texttt{pde}.
	\begin{lstlisting}
	base_directorio_paginas = 0xFFFFF000 AND pde
	\end{lstlisting}

	\item Calculamos el offset dentro del directorio de páginas en base a
	\texttt{virtual}.
	\begin{lstlisting}
	offset_directorio_paginas = ((0x003FF000 AND virtual) >> 12) << 2
	\end{lstlisting}

	\item Obtenemos el puntero al Page Table Entry correspondiente.
	\begin{lstlisting}
	ptr_pte = base_directorio_paginas + offset_directorio_paginas
	\end{lstlisting}

	\item Asignamos al Page Table Entry la dirección de la \texttt{física} y los
	atributos \texttt{attrs} y forzamos que se limpien las tablas cacheadas para
	evitar la posibilidad de estar leyendo una entrada desactualizada.
	\begin{lstlisting}
	*ptr_pte = (0xFFFFF000 AND fisica) OR attrs
	Limpio cache de tablas
	\end{lstlisting}
\end{enumerate}

\subsubsection*{Desmapeado}

La función \texttt{mmu\_unmapear\_pagina} toma como parámetros la dirección
\texttt{virtual} y el contenido del registro \texttt{cr3}. Los primeros 6 pasos
serán idénticos a los de \texttt{mmu\_mapear\_pagina}.

\begin{enumerate}
	\setcounter{enumi}{6}
	\item Seteamos en el Page Table Entry el bit de \texttt{present} en 0 y
		limpamos las tablas cacheadas para reflejar los cambios.
	\begin{lstlisting}
	*ptr_pte = *ptr_pte AND 0xFFFFFFFE
	Limpio cache de tablas
	\end{lstlisting}
\end{enumerate}

\subsubsection{Generación del directorio de páginas}

Para mapear las direcciones solicitadas, desarrollamos la función
\texttt{mmu\_inicializar\_dir\_kernel} que se encarga de generar la primer
entrada en el directorio de tablas y su tabla de páginas asociada.

\begin{enumerate}
	\item Primero creamos nuestro Page Directory Entry en la dirección
		\texttt{0x27000}.
	\begin{lstlisting}
	ptr_pd = 0x27000
	*ptr_pd = 0 // Limpiamos la entrada
	*ptr_pd = *ptr_pd OR 0x3 // Asignamos atributos
	\end{lstlisting}
	El número \texttt{0x3} equivale en binario a \texttt{11}. Estos dos primeros
	bits encendidos corresponden dentro del Page Directory Entry a que el
	directorio de páginas estará presente y que además podrá ser leído y
	escrito.
	\begin{lstlisting}
	*ptr_pd = *ptr_pd OR 0x28000 // Asignamos direccion
	\end{lstlisting}

	\item Llenamos el directorio de páginas aplicándole a cada entrada los
		mismos atributos descritos en el punto anterior.
	\begin{lstlisting}
	Para i de 0 a 1024
		direccion_pagina = i << 12
		mmu_mapear_pagina(direccion_pagina, 0x27000, direccion_pagina, 0x3)
	Fin para
	\end{lstlisting}
\end{enumerate}

\subsubsection{Activación de la paginación}

Finalmente, teniendo las rutinas explicadas previamente, procedimos a activar la
paginación en el procesador. El código siguiente corresponde a una sección del
kernel.

\begin{enumerate}
	\item Llamamos a nuestra rutina de inicialización del directorio de tablas
	\begin{lstlisting}
	call mmu_inicializar_dir_kernel
	\end{lstlisting}

	\item Cargamos la dirección del directorio de tablas en el registro
		\texttt{cr3}.
	\begin{lstlisting}
	mov eax, 0x00027000
	mov cr3, eax
	\end{lstlisting}

	\item Activamos la paginación encendiendo el bit más significativo del
		registro \texttt{cr0}.
	\begin{lstlisting}
	mov eax, cr0
	or eax, 0x80000000
	mov cr0, eax
	\end{lstlisting}
\end{enumerate}

\subsection{Tareas}

\subsubsection{Entradas de la GDT}

Al llegar a esta parte del trabajo tuvimos que agregar 18 entradas nuevas a la GDT, estas describen las TSS's de tarea\_inicial, IDLE, los 8 perros posibles que puede tener el jugador A simultaneamente y lo mismo para el jugador B. Estos segmentos van del numero 13 al 30

Para configurar las entradas de la gdt se pone como base el 0, esto será luego seteado correctamente por \textit{tss\_inicializar} la cual pone la dirección de la ubicación de la tss correspondiente, cada segmento tendrá como limite 104 Bytes (0x0067) para que la GDT interprete eso como bytes ponemos la granularidad en 0. El nivel de privilegio para las tareas de los jugadores será de 3. Las tareas que serán manejadas unicamente por el sistema, \textit{tarea\_inicial} y IDLE tendran el DPL en 0. El bit de present va en 1 para todos los segmentos y todo lo demás quedara en 0.

\subsubsection{Inicialización de las TSS}
Para completar las TSS's esta la función \textbf{tss\_inicializar}, esta como se dijo previamente pone la base correcta a los 18 segmentos descriptores de TSS's. En el codigo se puede ver el macro TSS\_PERRO\_ENTRY el cual esta definido en \textit{tss.h} y realiza dicha operación de seteo de base para los segmentos de los perros.

Para la configuración de las opciones de la TSS IDLE pusimos la dirección de la pila en el mismo lugar que la del kernel (0x27000), aunque las pilas de menores privilegios, esp1 y esp2 estan en 0, cr3 vale igual que el cr3 del kernel, iomap vale 0xFFFF, y los selectores de segmentos se pusieronsegun correspondian. En eip ponemos la dirección de la tarea la cual se aclara en la consigna que es la 0x16000.

Una vez que esta todo configurado, inicializamos las tss y cargamos la tarea inicial en kernel.asm

\begin{lstlisting}
	; Cargar tarea inicial
	mov ax, 0x68
	ltr ax
\end{lstlisting}

\subsubsection{Construcción de Tareas}


\subsubsection{La Interrupción 0x46}
En nuestro sistema operativo la interrupción 0x46 es la rutina de atención de servicios, es ejecutada por los jugadores para decidir las acciones de los perros. Estas pueden variar entre  \textit{game\_perro\_mover}, \textit{game\_perro\_cavar}, \textit{game\_perro\_olfatear} y \textit{game\_perro\_recibir\_orden} todos estos métodos estan definidos en \textit{perro.c} por la catedra. Una vez hecha la acción si todavia el quantum no se acabo se llama a la tarea idle para que esta espere hasta el turno del siguiente jugador.